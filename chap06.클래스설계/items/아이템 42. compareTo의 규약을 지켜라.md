# 아이템 42. compareTo의 규약을 지켜라
compareTo 메서드는 Any클래스에 있는 메서드가 아니다. 이는 수학적인 부등식으로 변환되는 연산자이다.

```kotlin
obj1 > obj2 // obj1.compareTo(obj2) > 0 으로 바뀐다
obj1 < obj2 // obj1.compareTo(obj) < 0 으로 바뀐다
obj1 >= objs // obj1.compareTo(obj2) >= 0 으로 바뀐다
obj1 <= obj2 // obj1.compareTo(obj2) <= 0 으로 바뀐다
```

참고로 compareTo 메서드는 `Comparable<T>` 인터페이스에도들어 있다. 어떤 객체가 이 인터페이스를 구현하고 있거나 compareTo라는 연산자 메서드를

갖고 있다는 의미는 해당 객체가 어떤 순서를 갖고 있으므로, 비교할 수 있다는 것이다. compareTo는 다음과 같이 동작해야한다

- `비대칭적 동작`: a>=b 이고 b>=a 라면 a==b여야 한다. 즉, 비교와 동등성 비교에 어떠한 관계가 있어야 하며, 서로 일관성 있어야 한다
- `연속적 동작`: a>=b 이고 b>=c라면, a>=c여야 한다. 마찬가지로 a>b 이고 b>c라면, a>c 여야 한다. 이러한 동작을 하지못하면 무한반복에 빠질 수있다
- `코넥스적 동작`: 두 요소는 어떤 확실한 관계를 갖고 있어야 한다. 즉, a>=b 또는 b>=a 중에 적어도 하나는 항상 true여야 한다.

## compareTo를 따로 정의해야 할까?
코틀린에서 compareTo를 따로 정의해야 하는 상황은 거의 없다. 일반적으로 어떤 프로퍼티 하나를 기반으로 순서를 지정하는 것으로 충분하기 때문이다

예를 들어 sortedBy를 사용하면, 원하는 키로 컬렉션을 정렬할 수 있다.
```kotlin
class User(val name: String, val surname: String)
val names = listOf<User>{/*...*/}

val sorted = names.sortedBy {it.surname}
```

여러 프로퍼티를 기반으로 정렬해야 한다면? 그럴 때는 sortedWith 함수를 사용하면 된다. 이 함수는 다음과 같이 사용한다.

compareBy를 활용해서 비교기(comparator)를 만들어서 사용한다. 다음 코드는 surname으로 정렬하고, 만약 surname이 같은경우에는 name까지 비교해 정렬한다

```kotlin
val sorted = names
    .sortedWith(compareBy( {it.surname}, {it.name}))
```

물론 User가 `Comparable<User>` 를 구현하는 형태로 만들 수도 있다. 이럴 때는 순서를 어떻게 해야할까?

특정 프로퍼티를 기반으로 정렬하게 하면 된다. 만약 비교에 대한 절대적인 기준이 없다면, 아예 비교하지 못하게 만드는 것도 좋다

문자열은 알파벳과 숫자 등의 순서가 있다. 따라서 내부적으로 `Comparable<String>`을 구현하고 있다. 텍스트는 일반적으로 

알파벳과 숫자 순서로 정렬해야 하는 경우가 많으므로 굉장히 유용하지만 단점도 있다.

```kotlin
// 이렇게 하지 마세요
print ("Kotlin" > "Java") // true

```

자연스러운 순서를 갖는 객체들이 있다. 예를 들어 측정 단위, 날짜, 시간 등이 모두 자연스러운 순서를 갖는다. 객체가 자연스러운 순서인지 확실하지 않다면,

비교기 (comparator)를 사용한느 것이 좋다. 이를 자주 사용한다면, 클래스에 companion 객체로 만들어 두는것도 좋다.

```kotlin
class User(val name: String, val surname: String) {
    //...

    companion object {
        val DISPLAY_ORDER = compareBy(User::surname, User::name)
    }
}
val sorted = names.sortedWith(User.DISPLAY_ORDER)
```

## compareTo 구현하기

compareTo를 구현할 때 유용하게 활용할 수 있는 톱레벨 함수가 있다. 두 값을 단순하게 비교하기만 한다면, compareValues함수를 다음과 같이 활용할 수있다.

```kotlin
class User(
    val name: String,
    val surname: String
): Comparable<User> {
    override fun compareTo(other: User): Int =
        compareValues(surname, other.surname)
}
```

더 많은 값을 비교하거나, 선택기(selector)를 활용해서 비교하고 싶다면, 다음과 같이 compareValuesBy를 사용한다

```kotlin
class User(
    val name: String,
    val surname: String
): Comparable<User> {
    override fun compareTo(other: User): Int =
        compareValuesBy(this, ither, {it.surname}, {it.name})
}
```

이 함수는 비교기를 만들 때 도움이 된다, 특별한 논리를 구현해야하는 경우에는 이 함수가 다음 값을 리턴해야 한다는 것을 기억하자.
- 0: 리시버와 other가 같은 경우
- 양수: 리시버가 other 보다 큰 경우
- 음수: 리시버가 other 보다 작은 경우

이를 구현한 뒤에는 이 함수가 비대칭적 동작, 연속적 동작, 코넥스적 동작을 하는지 확인하라.