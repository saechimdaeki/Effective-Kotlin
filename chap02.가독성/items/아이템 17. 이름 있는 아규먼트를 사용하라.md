# 아이템 17. 이름 있는 아규먼트를 사용하라

코드에서 아규먼트의 의미가 명확하지 않은 경우가 있다. 다음 옐르 살펴보자.

```kotlin
val text = (1..10).joinToString("|")
```
'|'는 무엇을 의미할까? 만약 joinToString에 대해서 알고 있다면 이것이 구분자를 의미한다는 것을 알 것이다. 하지만 모른다면 접두사로 생각할 수 있을 것이다.

따라서 명확하지 않게 보일 수 있다. 파라미터가 명확하지 않은 경우에는 이를 직접 지정해서 명확하게 만들어 줄 수 있다. 다음 코드처럼 이름 있는 아규먼트를 사용하면 된다.

```kotlin
val text = (1..10).joinToString(separator = "|")
```

또는 다음과 같이 변수를 사용해서도 의미를 명확하게 할 수 있다.

```kotlin
val separator = "|"
val text = (1..10).joinToString(separator)
```

물론 이름 있는 파라미터를 사용하면 더 신뢰할 수 있다. 변수 이름을 사용하는 방법도 개발자의 의도를 쉽게 알 수 있지만, 실제로 코드에서 제대로 사용되고 있는지는 알 수 없다.

변수를 잘못 만들 수도 있고, 함수 호출 때 잘못된 위치에 배치할 수도 있다. 이름 있는 아규먼트는 이러한 문제가 발생하지 않는다.

그래서 변수를 사용할 때도 이름 있는 아규먼트를 함께 활용하면 좋다.

```kotlin
val separator = "|"
val text = (1..10).joinToString(separator = separator)
```
## 이름 있는 아규먼트는 언제 사용해야 할까?

이름 있는 아규먼트를 사용하면 코드가 길어지지만, 다음과 같은 두 가지 장점이 생깁니다.

- 이름을 기반으로 값이 무엇을 나타내는지 알 수 있다. 
- 파라미터 입력 순서와 상관 없으므로 안전하다

아규먼트 이름은 함수를 사용하는 개발자뿐만 아니라 코드를 읽는 다른 사람들에게도 굉장히 중요한 정보다.

```kotlin
sleep(100)
```

이는 100ms인지 100s인지 명확하지 않다. 이름 있는 아규먼트를 활용하면 명확해진다

```kotlin
sleep(timeMillis = 100)
```

다음과 같이 함수를 만들어서 시간 단위를 표현할 수도 있다.

```kotlin
sleep(Millis(100))
```

또는 확장 프로퍼티로 DSL과 유사한 문법을 만들어 활용할 수도 있다.

```kotlin
sleep(100.ms)
```

타입은 이러한 정보를 전달하는 굉장히 좋은 방법이라고 할 수 있다. 만약 성능에 영향을 줄 것같아서 걱정된다면 아이템46에서 다루는 인라인 클래스를 사용하자.

특히 다음과 같은 경우에 이름있는 아규먼트를 추천한다
- 디폴트 아규먼트의 경우
- 같은 타입의 파라미터가 많은 경우
- 함수 타입의 파라미터가 있는 경우(마지막 경우 제외)

## 디폴트 아규먼트의 경우

프로퍼티가 디폴트 아규먼트를 가질 경우, 항상 이름을 붙여서 사용하는 것이 좋다. 일반적으로 함수 이름은 필수 파라미터들과 관련되어 있기 때문에 

디폴트 값을 갖는 옵션 파라미터의 설명이 명확하지 않다. 따라서 이러한 것들은 이름을 붙여서 사용하는 것이 좋다.

## 같은 타입의 파라미터가 많은 경우

파라미터가 모두 다른 타입이라면, 위치를 잘못 입력하면 오류가 발생할 것이므로 쉽게 문제를 발견할 수 있다. 하지만 파라미터에 같은 타입이 있다면,

잘못 입력했을 때 문제를 찾아내기 어려울 수 있다.

```kotlin
fun sendEmail(to: String, message: String) { /*...*/ }
```

이러한 함수가 있다면, 이름 있는 아규먼트를 사용하는 것이 좋다.

```kotlin
sendEmail(
    to = "contact@kt.academy"
    message = "Hello, ..."
)
```

## 함수 타입 파라미터

마지막으로, 함수 타입 파라미터는 조금 특별하게 다루어야 한다. 일반적으로 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋다.

함수 이름이 함수 타입 아규먼트를 설명해 주기도 한다. 예를 들어 `repeat`를 생각해보자. `repeat` 뒤에 오는 람다는 반복될 블록을 나타낸다.

thread도 그 이후의 블록이 스레드 본문이라는 것을 쉽게 알 수 있다. 이러한 이름들은 일반적으로 마지막에 위치하는 함수 파라미터에 대해서만 설명한다

```Kotlin
thread{
    // ...
}
```

그 밖의 모든 함수 타입 아규먼트는 이름 있는 아규먼트를 사용하는 것이 좋다. 예를 들어 뷰 DSL을 살펴보자

```kotlin
val view = linearLayout {
    text("Click below")
    button({/* 1 */ }, { /* 2 */ })
}
```

`{/* 1 */ }, { /* 2 */ }` 부분 중 어떤 부분이 빌더부분이고 어떤 부분이 리스너일까? 이름을 부여하고 위치를 수정하면 명확해진다.

```kotlin
val view = linearLayout {
    text("Click below")
    button(onClick = {/* 1 */}) {
        /* 2 */
    }
}
```

여러 함수 타입의 옵션 파라미터가 있는 경우에는 더 헷갈린다

```kotlin
fun call(before: () -> Unit = {}, after: () -> Unit = {}) {
    before()
    print("Middle")
    after()
}

call({print("CALL")}) // CALLMiddle
call({print("CALL")}) // MiddleCALL
```

이름을 붙여서 사용하면, 훨씬 더 쉽게 이해할 수 있다.

```kotlin
call(before = {print("CALL")}) // CALLMiddle
call(after = {print("CALL")}) // MiddleCALL
```

리액티브 라이브러리에서 굉장히 자주 볼 수 있는 형태이다. 예를 들어 RxJava에서 Observable을 구독할 때 함수를 설정한다
- 각각의 아이템을 받을 때(onNext)
- 오류가 발생했을 때(onError)
- 전체가 완료되었을 때(onComplete)

자바에서는 일반적으로 람다 표현식을 사용해서 코드를 작성하고, 주석을 활용해서 설명을 붙인다.

```java
observable.getUsers()
    .subscribe((List<User> users) -> { // onNext
        // ...
    }, (Throwable throwable) -> { // onError
        // ...
    }, () -> { // onCompleted
        // ...
    });
```

코틀린에서는 다음과 같이 이름 있는 아규먼트를 활용해서 의미를 더 명확하게 할 수 있다.

```kotlin
observable.getUsers()
    .subscribeBy(
        onNext = { users: List<User> ->
            // ...
        },
        onError = { throwable: Throwable ->
            // ...
        },
        onCompleted = {
            //...
        })
```

참고로 자바에서 subscribe라고 작성했던 코드를 코틀린에서는 subscribeBy로 변경했는데 이는 RxJava가 자바로 작성되어 있으며, 자바 함수를

호출할 때는 이름있는 파라미터를 사용할 수 없기 때문이다. 이름 있는 파라미터를 사용하려면, 이처럼 함수를 활용하는 별도의 코틀린 함수를 만들어서 사용해야 한다.


# 아이템 17 - 정리

이름 있는 아규먼트는 디폴트 값들을 생략할 때만 유용한 것이 아니다. 이름 있는 아규먼트는 개발자가 코드를 읽을 때도 편리하게 활용되며, 코드의 안정성도 

향상시킬 수 있다. 또한 함수에 같은 타입의 파라미터가 여러 개 있는 경우, 함수 타입의 파라미터가 있는 경우, 옵션 파라미터가 있는 경우는

이름 있는 아규먼트를 활용하는 것이 좋다. 예외는 마지막 파라미터가 DSL처럼 특별한 의미를 갖고 있는 경우이다.