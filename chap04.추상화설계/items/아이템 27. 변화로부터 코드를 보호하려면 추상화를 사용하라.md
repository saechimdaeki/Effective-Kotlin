# 아이템 27. 변화로부터 코드를 보호하려면 추상화를 사용하라

함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있다. 그리고 이후에 실질적인 코드를

원하는대로 수정할 수도 있다. 추상화를 통해 변화로부터 코드를 보호하는 행위가 어떤 자유를 가져오는지 살펴보자. 

## 상수
리터럴은 아무것도 설명하지 않는다. 따라서 코드에서 반복적으로 등장할 때 문제가 된다. 이러한 리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미 있는

이름을 붙일 수 있으며, 상수의 값을 변경해야 할 때 훨씬 쉡게 변경할 수 있다. 비밀번호 유효성을 검사하는 간단한 예를 살펴보자.

```kotlin
fun isPasswordValid(text: String): Boolean {
    if(text.length < 7) return false
    // ...
}
```

여기서 숫자 7은 아마 비밀번호의 최소 길이를 나타내겠지만 이해하는데 시간이 걸린다. 상수로 빼낸다면 훨씬 쉽게 이해할 수 있을 것이다.

```kotlin
const val MIN_PASSWORD_LENGTH = 7

fun isPasswordValid(text: String): Boolean {
    if(text.length < MIN_PaSSWORD_LENGTH) return false
    // ...
}
```

이렇게 하면 비밀번호의 최소 길이를 변경하기도 쉽다. 함수의 내부 로직을 전혀 이해하지 못해도, 상수의 값만 변경하면 된다. 그래서 두 번 이상 

사용 되는 값은 이렇게 상수로 추출하는 것이 좋다. 예를 들어 데이터베이스에 동시에 연결할 수 있는 최대 스레드 수를 다음과 같이 정의했다고 하자.

```Kotlin
val MAX_THREADS = 10
```

일단 이렇게 추출하면 변경이 필요할 때 쉽게 변경할 수 있다. 이러한 숫자가 프로젝트 전체에 퍼져 있다면 변경하기 정말 힘들 것이다.

상수로 추출하면
- 이름을 붙일 수 있고,
- 나중에 해당 값을 쉽게 변경할 수 있다.

## 함수

애플리케이션을 개발하고 있는데, 사용자에게 토스트 메시지를 자주 출력해야 하는 상황이 있다고 하자. 기본적으로는 다음과 같은 코드를 사용한다

```kotlin
Toast.makeText(this, message, Toast.LENGTH_LONG).show()
```


이렇게 많이 사용되는 알고리즘은 다음과 같이 확장 함수로 만들어서 사용할 수 있다.

```kotlin
fun Context.toast(
    message: String,
    duration: Int = Toast.LENGTH_LONG
) {
    Toast.makeText(this, message, duration).show()
}

// 사용
context.toast(message)

// 액티비티 또는 컨텍스트의 서브클래스에서 사용할 경우
toast(message)
```

이렇게 일반적인 알고리즘을 추출하면, 토스트를 출력하는 코드를 항상 기억해 두지 않아도 괜찮다. 또한 이후에 토스트를 출력하는 방법이 변경되어도,

확장 함수 부분만 수정하면되므로 유지보수성이 향상된다. 만약 토스트가 아니라 스낵바라는 다른 형태의 방식으로 출력해야한다면?

```kotlin
fun Context.snackbar(
    message: String,
    length: Int = Toast.LENGTH_LONG
) {
    // ...
}
```

하지만 이런 해결 방법은 좋지 않다. 내부적으로만 사용하더라도 함수의 이름을 직접 바꾸는 것은 위험할 수 있다.

다른 모듈이 이함수에 의존하고 있다면, 다른 모듈에 큰 문제가 발생할 것이다. 또한 함수의 이름은 한꺼번에 바꾸기 쉽지만, 파라미터는 한꺼번에 바꾸기가 쉽지 않으므로,

메시지의 지속시간을 나타내기 위한 Toast.LENGTH_LONG이 계속 사용되고 있다는 문제도 있다. 스낵바를 출력하는 행위가 토스트의 필드에

영향을 받는 것은 좋지 않다. 다른 한편으로는 스낵바의 enum으로 모든 것을 변경하는 것도 문제를 발생시킬 수 있다.

```kotlin
fun Context.snackbar(
    message: String,
    duration: Int = Snackbar.LENGTH_LONG
) {
    // ...
}
```

메시지의 출력 방법이 바뀔 수 있다는 것을 알고 있다면, 이때부터 중요한 것은 메시지의 출력 방법이 아니라, 사용자에게 메시지를 출력하고 싶다는 의도 자체이다.

따라서 메시지를 출력하는 더 추상적인 방법이 필요하다. 토스트 출력을 토스트라는 개념과 무관한 showMessage라는 높은 레벨의 함수로 옮기자

```kotlin
fun Context.showMessage(
    message: String,
    duration: MessageLength = MessageLength.LONG
) {
    val toastDuration = when(duration) {
        SHORT -> Length.LENGTH_SHORT
        LONG -> Length.LENGTH_LONG
    }
    Toast.makeText(this, message, toastDuration).show()
}

enum class MessageLength { SHORT, LONG }
```

가장 큰 변화는 이름이다. 함수는 추상화를 표현하는 수단이며, 함수 시그니처는 이 함수가 어떤 추상화를 표현하고 있는지 알려준다. 따라서 의미 있는 이름은 굉장히 중요하다.

함수는 매우 단순한 추상화지만, 제한이 많다. 예를 들어 함수는 상태를 유지하지 않는다. 또한 함수 시그니처를 변경하면 프로그램 전체에 큰 영향을 줄 수 있다.

## 클래스

이전의 메시지 출력을 클래스로 추상화해보자.

```kotlin
class MessageDisplay(val context: Context) {
    
    fun show(
        message: String,
        duration: MessageLengh = MessageLength.LONG
    ) {
        val toastDuration = when(duration) {
            SHORT -> Length.SHORT
            LONG -> Length.LONG
        }
        Toast.makeText(context, message, toastDuration)
            .show()
    }
}


enum class MessageLength { SHORT , LONG }

// 사용
val messageDisplay = MessageDisplay(context)
messageDisplay.show("Message")
```

클래스가 함수보다 더 강력한 이유는 상태를 가질 수 있으며, 많은 함수를 가질 수 있다는 점 때문이다. 현재 위의 코드에서 클래스의 상태인 context는

기본 생성자를 통해 주입된다. 의존성 주입 프레임워크를 사용하면 클래스 생성을 위임할 수도 있다.

```kotlin
@Inject lateinit var messageDisplay: MessageDisplay
```

또한 mock 객체를 활용해 해당 클래스에 의존하는 다른 클래스의 기능을 테스트할 수 있다.

```kotlin
val messageDisplay: MessageDisplay = mockk()
```

게다가 메시지를 출력하는 더 다양한 종류의 메서드를 만들 수도 있다.

```kotlin
messageDisplay.setChristmasMode(true)
```

이처럼 클래스는 훨씬 더 많은 자유를 보장해 준다. 하지만 여전히 한계가 있다. 예를 들어 클래스가 final이라면, 해당 클래스 타입 아래에 어떤 구현이

있는지 알 수 있다. open 클래스를 활용하면 조금은 더 자유를 얻을 수 있다. 더 많은 자유를 얻으려면, 더 추상적이게 만들면 된다. 

바로 인터페이스 뒤에 클래스를 숨기는 방법이다.

## 인터페이스

코틀린 표준 라이브러리를 읽어보면, 거의 모든 것이 인터페이스로 표현된다는 것을 확인할 수 있을 것이다. 예를 들어
- listOf 함수는 List를 리턴합니다. 여기서 List는 인터페이스입니다. listOf는 팩토리 메서드라고 할 수 있다.
- 컬렉션 처리 함수는 Iterable 또는 Collection의 확장 함수로서, List, Map 등을 리턴한다. 이것들은 모두 인터페이스이다.
- 프로퍼티 위임은 ReadOnlyProperty또는 ReadWriteProperty뒤에 숨겨진다. 이것들도 모두 인터페이스이다. 
  
  실질적인 클래스는 일반적으로 private이다. 함수 lazy는 Lazy 인터페이스를 리턴한다.

라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고, 인터페이스를 통해 이를 노출하는 코드를 많이 사용한다. 이렇게 하면 사용자가 클래스를

직접 사용하지 못하므로, 라이브러리를 만드는 사람은 인터페이스만 유지한다면, 별도의 걱정 없이 자신이 원하는 형태로 그 구현을 변경할 수 있다.

즉 인터페이스 뒤에 객체를 숨김으로써 실질적인 구현을 추상화하고, 사용자가 추상화된 것에만 의존하게 만들 수 있다. 즉 `결합(coupling)`을 줄일 수 있다.

코틀린이 클래스가 아니라 인터페이스를 리턴하는 데에는 이외에도 여러 이유가 있다. 예를 들어 코틀린은 멀티 플랫폼 언어이다. 따라서 listOf가

코틀린/JVM, 코틀린/JS, 코틀린/네이티브에 따라서 구현이 다른 리스트를 리턴한다. 다른 리스트를 사용하는 이유는 최적화 때문이다. 각 플랫폼의

네이티브 리스트를 사용해서 속도를 높이는 것이다. 어떤 플랫폼을 사용해도 List 인터페이스에 맞춰져 있으므로, 차이 없게 사용할 수 있다.

그럼 앞선 메시지 표시 예제에 인터페이스를 도입해보자.

```kotlin
interface MessageDisplay {
    fun show(
        message: String,
        duration: MessageLength = LONG
    )
}

class ToastDisplay(val context: Context): MessageDisplay {
    
    override fun show(
        message: String,
        duration: MessageLength
    ) {
        val toastDuration = when(duration) {
            SHORT -> Length.SHORT
            LONG -> Length.LONG
        }

        Toast.makeText(context, message, toastDuration)
            .show()
    }
}

enum class MessageLength { SHORT, LONG }
```

이렇게 구성하면 더 많은 자유를 얻을 수 있다. 이러한 클래스는 여러 플랫폼에서 사용할 수 있다. 각각의 플랫폼에서 구현만 조금 다르게 하면된다.

예를 들어 iOS, 웹에서는 경고창(alert)으로 출력하게 하는 것이다.

또 다른 장점은 테스트할 때 인터페이스 페이킹이 클래스 모킹보다 간단하므로, 별도의 모킹 라이브러리를 사용하지 않아도 된다는 것이다.

```kotlin
val messageDisplay: MessageDisplay = TestMessageDisplay()
```

마지막으로 선언과 사용이 분리되어 있으므로, ToastDisplay등의 실제 클래스를 자유롭게 변경할 수 있다. 다만 사용 방법을 변경하려면, 

MessageDisplay 인터페이스를 변경하고, 이를 구현하는 모든 클래스를 변경해야 한다.

## ID 만들기(nextId)
그럼 추가적인 예를 하나 살펴보자. 프로젝트에서 고유 ID를 사용해야 하는 상황을 가정하자. 가장 간단한 방법은 어떤 정수 값을 계속 증가시키면서, 이를 ID로 활용하는 것이다.

```kotlin
var nextId: Int = 0

// 사용
val newId = nextId++
```

그런데 이러한 코드가 많이 사용되면, 약간 위험하다. ID가 생성되는 방식을 변경할 때 문제가 발생하기 때문이다. 이방법은 다음과 같은 문제가 있다.

- 이 코드의 ID는 무조건 0부터 시작한다
- 이 코드는 스레드-안전(thread-safe)하지 않다.

만약 그래도 이방법을 사용해야 한다면, 일단 이후에 발생할 수 있는 변경으로부터 코드를 보호할 수 있게 함수를 사용하는 것이 좋다.

```kotlin
private var nextId: Int = 0
fun getNextId(): Int = nextId++

// 사용
val newId = getNextId()
```

이제 ID 생성 방식의 변경으로부터 보호되지만, ID 타입 변경 등은 대응하지 못한다. 미래의 어느 시점에 ID를 문자열로 변경해야 한다면?

여러 연산들이 타입에 종속적이게 작성되었다면? 이를 최대한 방지하려면, 이후에 ID타입을 쉽게 변경할 수 있게 클래스를 사용하는 것이 좋다.

```Kotlin
data class Id(private val id : Int)

private var nextId: Int = 0
fun getNextId(): Id = Id(nextId++)
```

더 많은 추상화는 더 많은 자유를 주지만, 이를 정의하고, 사용하고, 이해하는 것은 조금 어려워진다.

## 추상화가 주는 자유

지금까지 추상화를 하는 몇가지 방법을 정리해보면 다음과 같다.
- 상수로 추출한다
- 동작을 함수로 래핑한다
- 함수를 클래스로 래핑한다
- 인터페이스 뒤에 클래스를 숨긴다
- 보편적인 객체(universal object)를 특수한 객체(specialistic object)로 래핑한다

이를 구현할 때는 여러 도구를 활용할 수 있다.
- 제네릭 타입 파라미터를 사용한다
- 내부 클래스를 추출한다
- 생성을 제한한다(예를 들어 팩토리 함수로만 객체를 생성할 수 있게 만드는 등)

하지만 추상화에도 단점은 존재한다. 추상화는 자유를 주지만, 코드를 이해하고 수정하기 어렵게 만든다. 추상화의 단점에 대해서 살펴보자

## 추상화의 문제

어떤 방식으로 추상화를 하려면 코드를 읽는 사람이 해당 개념을 배우고, 잘 이해해야 한다. 또 다른 방식으로 추상활르 하려면 또 해당 개념을 배우고 이해해야 한다.

물론 추상화의 가시성을 제한하거나, 구체적인 작업에서만 추상활르 도입하는 것은 큰 문제가 없다, 그래서 큰 프로젝트에서는 잘 모듈화해야 한다.

어쨋거나 추상화도 비용이 발생한다. 따라서 극단적으로 모든 것을 추상화해서는 안된다. 추상화는 거의 무한하게 할 수 있지만, 어느 순간부터

득보다 실이 많아질 것이다. 추상환느 많은 것을 숨길 수 있는 테크닉이다. 생각할 것을 어느 정도 숨겨야 개발이 쉬워지는 것도 사실이지만

너무 많은 것을 숨기면 결괄르 이해하는 것 자체가 어려워진다. 추상화가 너무 많으면 코드를 이해하기 어렵다. 추상화가 많은 코드를 보면,

이해하기 어렵다는 생각 때문에 코드를 제대로 읽기도 전에 두려움에 사로잡힐 수 있다.

추상화를 이해하려면, 예제를 살펴보는 것이 좋다. 요소를 사용하는 방법을 보여주는 단위테스트와 문서의 예제는 추상화가 어떻게 사용되는지

확실하게 보여준다. 예제 없이 추상화를 설명하면 이해하기도 어렵고, 오해하기도 쉽다.

## 어떻게 균형을 맞추야 할까?

경험에 따르면 모든 추상화는 자유를 주지만, 코드가 어떻게 돌아가는 것인지 이해하기 어렵게 만든다. 극단적인 것은 언제나 좋지 않다. 최상의 답은

그 사이 어딘가에 있다. 정확한 위치는 다음과 같은 요소들에 따라서 달라질 수 있다.

- 팀의 크기
- 팀의 경험
- 프로젝트의 크기
- 특징 세트(feature set)
- 도메인 지식

따라서 프로젝트에 따라서 균형이 다를 수 있다. 적절한 균형을 찾는 것은 거의 감각에 의존해야 하는 예술에 가깝다. 수천 시간까지는 아니더라도,

수백 시간 이상의 경험이 있어야 할 수 있는 일이다. 그래도 사용할 수 있는 몇가지 규칙을 정리해 보면 다음과 같다.

- 많은 개발자가 참여하는 프로젝트는 이후에 객체 생성과 사용 방법을 변경하기 어렵다. 따라서 추상화 방법을 사용하는 것이 좋다. 최대한 모듈과 부분을 분리하는 것이 좋다.
- 의존성 주입 프레임워크를 사용하면, 생성이 얼마나 복잡한지는 신경쓰지 않아도 된다. 클래스 등은 한 번만 정의하면 되기 때문이다.
- 테스트를 하거나, 다른 애플리케이션을 기반으로 새로운 애플리케이션을 만든다면 추상화를 사용하는 것이 좋다
- 프로젝트가 작고 실험적이라면, 추상화를 하지 않고도 직접 변경해도 괜찮다. 문제가 발생했다면, 최대한 빨리 직접 변경하면 된다.

항상 무언가 변화할 수 있다고 생각하는 것이 좋다. 이후에 더 일반적인 메커니즘이 필요할 가능성이 있는지, 플랫폼 독립적인 메커니즘이

필요할 수 있는지, 이러한 확률이 얼마나 되는지 등은 여러 가지 경험을 해보면 어느정도 알 수 있게 된다.

# 아이템 27 - 정리

추상화는 단순하게 중복성을 제거해서 코드를 구성하기 위한 것이 아니다. 추상화는 코드를 변경해야 할 때 도움이 된다. 따라서 추상화를

사용하는 것은 굉장히 어렵지만, 이를 배우고 이해해야 한다. 다만 추상적인 구조를 사용하면, 결과를 이해하기 어렵다. 추상화를 사용할 때의

장점과 단점을 모두 이해하고, 프로젝트 내에서 그 균형을 찾아야 한다. 추상화가 너무 많거나 너무 적은 상황 모두 좋은 상황이 아니다.