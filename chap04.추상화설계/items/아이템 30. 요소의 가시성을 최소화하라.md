# 아이템 30. 요소의 가시성을 최소화하라.

API를 설계할 때 가능한 한 간결한 API를 선호하는 데는 여러가지 이유가 있다. 중요한 몇가지를 살펴보자.

작은 인터페이스는 배우기 쉽고 유지하기 쉽다. 기능이 많은 클래스보다는 적은 클래스를 이해하는 것이 쉽다. 또한 유지보수하기도 쉽다.

일반적으로 어떤 수정을 가하기 위해서는 클래스 전체를 이해하고 있어야한다. 보이는 요소 자체가 적다면, 유지보수하고 테스트할 것이 적다.

변경을 가할 때는 기존의 것을 숨기는 것보다 새로운 것을 노출하는 것이 쉽다. 일반적으로 공개적으로 노출되어 있는 요소들은 공개 API의 일부이며,

외부에서 사용할 수 있다. 따라서 이러한 요소들은 이미 외부에서 사용되고 있을 것이다. 그래서 이런 요소들을 변경하면, 이 코드를 사용하는 모든 부분이 영향을 받는다.

이러한 변경은 신중하게 고려해야 하며, 변경할 경우에는 대체재를 제공해야 한다. 다만 다른 개발자가 구현한 코드에 대한 대체재를 제공하는 것은 어려울 수 있다.

비즈니스 요구 사항이 무엇인지 빠르게 파악하기 어려울 수 있다. 따라서 처음에는 작은 API로서 개발을 하도록 강제하는 것이 더 좋을 수 있다.

클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면, 클래스는 자신의 상태를 보장할 수 없다. 클래스가 만족해야 하는 클래스의 상태에 대한

규약 등이 있을 수 없다. 클래스가 만족해야 하는 클래스의 상태에 대한 규약 등이 있을 수 있다. 이러한 규약을 모르는 사람은 클래스의 상태를 마음대로

변경할 수 있으므로, 클래스의 불변성이 무너질 가능성이 있다. 이전에 보았던 CounterSet을 다시 살펴보자. 이 코드는 세터를 private로 설정했었다.

이부분이 없다면 외부에서 이 코드를 강제로 바꿀 수 없고, 이 프로퍼티에 대한 신뢰성에 문제가 생길 수 있다. 

```kotlin
class CounterSet<T>(
    private val innerSet: MutableSet<T> = setOf()
) : MutableSet<T> by innerSet {

    var elementsAdded : Int = 0
        private set
    
    override fun add(element: T): Boolean {
        elementsAdded++
        return innerSet.add(element)
    }
    
    override fun addAll(elements: Collection<T>) : Boolean {
        elementsAdded += elements.size
        return innerSet.addAll(elements)
    }
}
```

일반적으로 코틀린에서는 이처럼 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋다. 서로서로 의존하는 프로퍼티가 있을 때는 객체 상태를 보호하는 것이

더 중요하다. 예를 들어 mutableLazy 델리게이트를 구현할 때를 생각하면 initialized가 true면 값 초기화가 이루어지고, 이때의 값은 T타입이라는 것을

예상할 수 있다. 이때 initialized의 세터가 노출되어서는 안된다. 이것이 노출되면 예상하지 못한 변경에 의해서 예외가 발생하고, 코드의 신뢰성이 떨어진다.

```Kotlin
class MutableLazyHolder<T>(val initializer: () -> T) {

    private var value: Any = Any()
    private var initialized = false

    override fun get() : T {
        if (!initialized) {
            value = initializer()
            initialized = true
        }
        return value as T
    }

    override fun setValue() {
        this.value = value
        initialized = true
    }
}
```

가시성이 제한될수록 클래스의 변경을 쉽게 추적할 수 있으며, 프로퍼티의 상태를 더 쉽게 이해할 수 있다. 이는 동시성을 처리할 때 중요하다.

## 가시성 한정자 사용하기 
내부적인 변경 없이 작은 인터페이슬르 유지하고 싶다면, 가시성을 제한하면 된다. 기본적으로 클래스와 요소를 외부에 노출할 필요가 없다면,

가시성을 제한해서 외부에서 접근할 수 없게 만드는 것이 좋다. 가시성 제한은 가시성 한정자(visibility modifier)를 활용해서 구현한다

클래스 멤버의 경우 다음과 같은 4개의 가시성 한정자를 사용할 수 있다.
- `public(디폴트)` : 어디에서나 볼 수 있다.
- `private` : 클래스 내부에서만 볼 수 있다.
- `protected` : 클래스와 서브클래스 내부에서만 볼 수 있다.
- `internal` : 모듈 내부에서만 볼 수 있다.

톱레벨 요소에는 세 가지 가시성 한정자를 사용할 수 있다.
- `public(디폴트)` : 어디에서나 볼 수 있다.
- `private` : 같은 파일 내부에서만 볼 수 있다.
- `internal` : 모듈 내부에서만 볼 수 있다.

참고로 모듈과 패키지를 혼동하는 개발자들이 있는데, 의미가 다르다. 코틀린에서 모듈이란 함게 컴파일되는 코틀린 소스를 의미한다. 따라서 다음을 의미한다.
- 그레이들(Gradle) 소스 세트
- 메이븐(Maven) 프로젝트
- 인텔리제이(IntelliJ) IDEA 모듈
- 앤트(Ant) 태스크 한 번으로 컴파일되는 파일 세트

만약 모듈이 다른 모듈에 의해서 사용될 가능성이 있다면, internal을 사용해서 공개하고 싶지 않은 요소를 숨긴다. 요소가 상속을 위해 설계되어 있고, 클래스와

서브클래스에서만 사용되게 만들고 싶다면 protected를 사용한다. 동일한 파일 또는 클래스에서만 요소를 사용하게 만들고 싶다면 private을 사용한다.

참고로, 코틀린은 지역적으로만 사용되고 있는 요소는 private으로 만드는 것이 좋다는 컨벤션을 다음과 같이 제공해 준다.

![image](https://user-images.githubusercontent.com/40031858/182498677-8783c2b1-a57a-4e5a-9433-3f57bb2321ee.png)


이러한 규칙은 데이터를 저장하도록 설계된 클래스(DTO)에는 적용하지 않는 것이 좋다. 데이터를 저장하도록 설계된 클래스는 숨길 이유가 없기 때문이다.

따라서 프로퍼티를 사용할 수 있게 눈에 띄게 만드는 것이 좋으며, 필요하지 않은 경우 그냥 프로퍼티를 제거하는 것이 좋다.

```kotlin
class User(
    val name: String,
    val surname: String,
    val age: Int
)
```

한 가지 큰 제한은, API를 상속할 때 오버라이드해서 가시성을 제한할 수는 없다는 것이다. 이는 서브클래스가 슈퍼클래스로도 사용될 수 있기 때문이다.

이것이 상속보다는 컴포지션을 선호하는 대표적인 이유이다.

# 아이템 30 - 정리
필자의 경험으로는 요소의 가시성은 최대한 제한적인 것이 좋다. 보이는 요소들은 모두 public API로서 사용되며, 다음과 같은 이유로 최대한 단순한 것이 좋다
- 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽다.
- 최대한 제한이 되어 있어야 변경하기 쉽다.
- 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없다.
- 가시성이 제한되면 API의 변경을 쉽게 추적할 수 있다.