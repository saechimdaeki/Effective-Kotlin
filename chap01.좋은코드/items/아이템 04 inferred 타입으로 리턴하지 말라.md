# 아이템 4. inferred 타입으로 리턴하지 말라 

코틀린의 타입 추론(type inference)은 JVM 세계에서 가장 널리 알려진 코틀린의 특징이다.

다만 타입 추론을 사용할 때는 몇 가지 위험한 부분들이 있다. 이러한 위험한 부분을 피하려면, 우선 할당 때 inferred 타입은 정확하게 오른쪽에 있는

피연산자에 맞게 설정된다는 것을 기억해야 한다. 절대로 슈퍼클래스 또는 인터페이스로는 설정되지 않는다

```kotlin
open class Animal
class Zebra: Animal()

fun main() {
    var animal = Zebra()
    animal = Animal() // 오류: type mismatch
}
```

일반적인 경우에는 이러한 것이 문제가 되지 않는다. 그냥 원하는 타입보다 제한된 타입이 설정되었다면, 타입을 명시적으로 지정해서 이러한 문제를 해결할 수 있다.

```kotlin
open class Animal
class Zebra: Animal()

fun main() {
    var animal: Animal = Zebra()
    animal = Animal()
}
```

하지만 직접 라이브러리를 조작할 수 없는 경우에는 이러한 문제를 간단하게 해결할 수 없다. 그리고 이러한 경우에서 inferred 타입을 노출하면, 위험한 일이 발생할 수 있다.

간단한 예제를 살펴보자. 다음과 같은 CarFactory 인터페이스가 있다고 해보자.

```kotlin
interface CarFactory { 
    fun produce(): Car
}
```

또한 다른 것을 지정하지 않았을 경우, 다음과 같이 디폴트로 생성되는 자동차가 있다고 해보자.
```kotlin
val DEFAULT_CAR: Car = Fiat126p()
```

대부분의 공장에서 Fiat126P라는 자동차를 생산하므로, 이를 티폴트로 두었다고 가정하자. 코드를 작성하다 보니 DEFAULT_CAR는 Car로 명시적으로

지정되어 있으므로 따로 필요 없다고 판단해서, 함수의 리턴타입을 제거했다고 하자

```kotlin
interface CarFactory {
    fun produce() = DEFAULT_CAR
}
```

그런데 이후에 다른 사람이 코드를 보다가, DEFAULT_CAR는 타입 추론에 의해 자동으로 타입이 지정될 것이므로, Car를 명시적으로 지정하지 않아도 된다고 생각해서 코드를 변경했다고 해보자

```kotlin
val DEFAULT_CAR = Fiat126P()
```

이제 문제가 발생했다. CarFactory에서는 이제 Fiat126P이외의 자동차를 생산하지 못한다. 만약 인터페이스를 직접 만들었다면, 문제를 굉장히 쉽게 찾아서 수정할 수 있을것이다.

하지만 외부 API라면 문제를 쉽게 해결할 수 없다. 다른 사용자가 이런 외부 API를 썼다면, 화를 내면서 문제가 있다고 제작자에게 말하게 될것이다.

리턴 타입은 API를 잘 모르는 사람에게 전달해 줄 수 있는 중요한 정보이다. 따라서 리턴 타입은 외부에서 확인할 수 있게 명시적으로 지정해 주는 것이 좋다.

## 아이템 4 - 정리

타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야 한다는 원칙만 갖고 있으면 된다. 이는 중요한 정보이므로 숨기지 않는 것이 좋다.

또한 안전을 위해서 외부 API를 만들 때는 반드시 타입을 지정하고, 이렇게 지정한 타입을 특별한 이유와 확실한 확인 없이는 제거하지 말자.

inferred 타입은 프로젝트가 진전될 때, 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수 있다는 것을 기억하자