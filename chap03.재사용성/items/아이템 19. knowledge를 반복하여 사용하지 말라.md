# 아이템 19. knowledge를 반복하여 사용하지 말라

'프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다' 굉장히 단순한 휴리스틱이지만, 정말로 잘 들어맞는다.

이를 'knowledge'를 반복하여 사용하지 말라는 규칙으로 표현하고 있다.

## knowledge

프로그래밍에서 knowledge는 넓은 의미로 '의도적인 정보'를 뜻한다. 이와 같은 knowledge는 코드 또는 데이터로 표현할 수 있다. 또한 기본 동작을 하게 아예 코드와

데이터를 부족하게 만들어서도 표현할 수 있다. 상속을 하는데도 불구하고 특정 메서드를 오버라이드하지 않게 강제한다는 것은, '해당 메서드가 슈퍼클래스와 동일하게 동작하기 원한다'

라는 의미이다. 이처럼 프로젝트를 진행할 때 정의한 모든 것이 knowledge이다. 

프로그램에서 중요한 knowledge를 크게 두 가지 뽑는다면, 다음과 같다.

1. `로직(logic)`: 프로그램이 어떠한 식으로 동작하는지와 프로그램이 어떻게 보이는지
2. `공통 알고리즘(common algorithm)`: 원하는 동작을 하기 위한 알고리즘

둘의 가장 큰 차이점은 시간에 따른 변화이다. 비즈니스 로직은시간이 지나면서 계속해서 변하지만, 공통 알고리즘은 한 번 정의된 이후에는 크게 변하지 않는다.

물론 공통 알고리즘을 최적화를 하거나, 같은 카테고리의 더 빠른 알고리즘으로 바꿀 수도 있지만, 동작은 크게 변하지 않는다. 

## 모든 것은 변화한다

프로그래밍에서 유일하게 유지되는 것은 '변화한다는 속성'이라는 말이 있다. 오늘날 대부분의 프로젝트는 몇 달마다 요구 사항과 내부적인 구조를 계속해서 변경한다.

이는 바람직한 일이다. 널리 사용되는 많은 관리 시스템은 애자일(agile)하며, 요구 사항의 변화를 맞추는 데 적합하다. 

모든 것은 변화하고, 우리는 이에 대비해야 한다. 변화할 때 가장 큰 적은 knowledge가 반복되어 있는 부분이다. 프로그램 내부에서 여러 부분에 

반복되어 있는 코드를 변경하려면 어떻게 해야할까? 가장 간단하게는 반복된 부분을 모두 찾고, 모두 변경하면 된다. 하지만 이러한 과정에서 검색 중 실수가

발생할 수 있고 무엇보다 귀찮다. 변경을 했어야 했는데, 실수로 변경을 하지 못한 부분은 어떻게 해야 할까? 모든 부분을 변경하는 것은 이처럼 힘들다.

이처럼 knowledge 반복은 위험하고 문제가 있다. knowledge 반복은 프로젝트의 확장성(scalable)을 막고, 쉽게 깨지게(fragile) 만든다.

다행히도 개발자는 knowledge 반복을 줄일 수 있는 도구와 기능들을 활용할 수 있다. 대부분의 플랫폼에서는 사용자 정의 스타일 기능을 통해

한꺼번에 전체적인 뷰와 컴포넌트의 디자인을 변경할 수 있다. SQL을 직접 장성하지 않고 하이버네이트와 같은 ORM, 익스포즈드와 같은 DAO를 활용할 수 있다.

여러 종류의 추상활르 표현할 수 있는 수많은 솔루션이 있으며, 이를 활용하면 반복을 줄일 수 있다. 이는 아이템 27에서 살펴보자.

## 언제 코드를 반복해도 될까?

반대로 추출을 통해 knowledge 반복을 줄이면 안 되는 상황을 보자. 결론부터 말하면 얼핏보면 knowledge 반복처럼 보이지만, 실질적으로 

다른 knowledge를 나타내므로 추출하면 안되는 부분이다.

어떤 프로젝트에서 독립적인 2개의 안드로이드 애플리케이션을 만들고 있다고 해보자. 빌드 도구 설정이 비슷할 것이므로 이를 추출해서 knowledge 반복을 줄일 수 있다고

생각할 수 있다. 하지만 두 애플리케이션은 독립적이므로 구성 변경이 일부 필요할 수도 있다. 

두 코드가 같은 knowledge를 나타내는지, 다른 knowledge를 나타내는지 '함께 변경될 가능성이 높은가? 따로 변경될 가능성이 높은가?' 라는 질문으로

어느 정도 결정할 수 있다. 코드를 추출하는 이유는 변경을 쉽게 만들기 위함이므로, 이 질문은 가장 근본적인 질문이라고 할 수 있다.

한 가지 유용한 휴리스틱으로, 비즈니스 규칙이 다른곳에서 왔는지 확인하는 방법이 있다. 다른 곳에서 왔다면, 독립적으로 변경될 가능성이 높다.

잘못된 코드 추출로부터 우리를 보호할 수 있는 규칙도 있다. 바로 `단일 책임 원칙(Single Responsibility Principle, SRP)`이다.

## 단일 책임 원칙

코드를 추출해도 되는지를 확인할 수 있는 원칙으로, SOLID 원칙 중 하나인 단일 책임 원칙이 있다. 단일 책임 원칙이란 '클래스를 변경하는 이유는 단 한가지여야 한다'

라는 의미이다. 간단한 예를 통해 살펴보자. 어떤 대학에서 Student라는 클래스를 갖고 있다고 하자. 이 클래스는 장학금과 관련된 부서와 인증과 관련된 부서에서

모두 사용된다. 두 부서에서는 Student라는 클래스에 대해서 다음과 같은 두 가지 프로퍼티를 추가했다.

- qualifiesForScholarship은 장학금 관련 부서에서 만든 프로퍼티로, 학생이 장학금을 받을 수 있는 포인트를 갖고 있는지 나타낸다
- isPassing은 인증 관련 부서에서 만든 프로퍼티로, 학생이 인증을 통과했는지를 나타낸다.

이 두 프로퍼티는 모두 학생의 이전 학기 성적을 기반으로 계산된다. 그래서 개발자는 두 프로퍼티를 한꺼번에 계산하는 calculatePointsFromPassedCourses 함수를 만들었다.

```kotlin
class Student {
    // ...

    fun isPassing(): Boolean = 
        calculatePointsFromPassedCourses() > 15
    
    fun qualifiesForScholarship(): Boolean =
        calculatePointsFromPassedCourses() > 30

    private fun calculatePointsFromPassedCourses(): Int {
        //...
    }
}
```

그런데 어느 날 학부장이 '덜 중요한 과목은 장학금 포인트를 줄여달라' 라고 요청해서, 규칙을 바꿔야 하는 상황이 생겻다. 이것을 변경하기 위해 파견된 

다른 개발자는 qualifiesForScholarship 프로퍼티를 확인하고, calculatePointsFromPassedCourses에서 이 값을 수정하고 있다는 것을 확인했다.

그리고 이를 기반으로 학부장의 요청 사항에 맞게 코드를 수정했다. 그런데 의도 하지 않게 isPassing도 비슷한 프로퍼티라고 생각해서, 이와 관련된 동작도 수정했다.

이렇게 되면 인증을 통과할 줄 알았던 학생이 통과하지 못할 수도 있다.

아마 개발자는 해당 함수가 활용되고 있는 다른 부분도 확인했을 것이다.

하지만 이 함수가 자신이 해야 하는 일 이외의 책임을 갖고 있을 거라는 예측하지 못한 것이다. 이는 일반적으로 private 함수는 두 가지 이상의 역할을

하지 않기 때문에, 이러한 관습에 따라서 생각했기 때문이다. 따라서 이런 문제를 방지하려면, 처음부터 책임에 따라서 다른 클래스로 구분해서 만들어야 한다.

예를 들어 책임에 따라 StudentIsPassingValidator와 StudentQualifiesForScholarshipValidator 클래스를 구분해서 만들엇다면?

간단하게 코틀린의 확장 함수를 활용하면, 두 함수는 Student 클래스 아래에 두면서도, 각각의 부서가 관리하는 서로 다른 모듈 파일에 배치할 수도 있을 것이다.

```kotlin
// accreditations 모듈
fun Student.qualifiesForScholarship(): Boolean {
    /*...*/
}

// scholarship 모듈
fun Student.calculatePointsFromPassedCourses(): Boolean {
    /*...*/
}
```

두 결과를 계산하는 추가적인 함수를 만들면? 할 수 있다. 그렇지만 헬퍼 함수는 private 함수로 만들지 않고, 다음과 같이 만드는 것이 일반적이다.

1. 두 부서에서 모두 사용하는 일반적인 public 함수로 헬퍼 함수를 만든다. 공통 부분은 두 부서에서 모두 사용하므로, 이를 함부로 수정해서는 안되게 규약을 정한다
2. 헬퍼 함수를 각각의 부서 모듈에 따라 2개 만든다

어떤 선택지를 사용해도 안전하다. 단일 책임 원칙은 우리에게 두 가지 사실을 알려준다

- 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 많다. 따라서 비슷한 처리를 하더라도, 완전히 다른 knowledge로 취급하는 것이 좋다
- 다른 knowledge는 분리해 두는 것이 좋다. 그렇지 않으면, 재사용해서는 안 되는 부분을 재사용하려는 유혹이 발생할 수 있다

# 아이템 19 - 정리
모든 것은 변화하다. 따라서 공통 knowledge가 있다면, 이를 추출해서 이러한 변화에 대비해야 한다 여러 요소에 비슷한 부분이 있는 경우, 변경이 필요할 때 실수가 발생할 수 있다.

이런 부분은 추출하는 것이 좋다. 추가적으로 의도하지 않은 수정을 피하려면 또는 다른 곳에서 조작하는 부분이 있다면, 분리해서 사용하는 곳이 좋다.

많은 개발자는 'Don't Repeat Yourself'라는 문장을 엄격하게 지키려고 비슷해 보이는 코드는 모두 추출하려는 경향이 있다. 극단적인 것은 언제나 좋지 않다.

항상 균형이 중요하다. 어떤 것을 추출해야 할지 결정하기 어려울 수 있다. 정보 시스템 설계는 예술의 영역과 비슷하기 때문에 수많은 연습이 필요하다.